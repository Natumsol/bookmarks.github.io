{"componentChunkName":"component---src-templates-blog-post-js","path":"/loading-script/","result":{"data":{"site":{"siteMetadata":{"title":"Notes.","author":"Natumsol"}},"markdownRemark":{"id":"7b654c4e-c8c6-514e-94c4-175a461a3de3","excerpt":"…","html":"<p><code class=\"language-text\">javascript</code>脚本有三种加载方式，分别为<code class=\"language-text\">&lt;script&gt;</code>，<code class=\"language-text\">&lt;script defer = &quot;defer&quot;&gt;</code>，<code class=\"language-text\">&lt;script async = &quot;async&quot;&gt;</code>。这三种方式有诸多不同，网络上有许多文章花了很大功夫去解释它们的异同，但大部分如老太太的裹脚布，又臭又长，看得人云里雾里。今天在网路上看到相关文章，很短，只有一幅图和一点解释性的文字，但是让人一看就懂。真是一图胜千言啊。</p>\n<p>摘录如下：</p>\n<p><img src=\"/images/blog/20151111/script.jpg\" alt=\"三种脚本加载的异同点\"></p>\n<p>可以很清晰的看出：</p>\n<ul>\n<li><code class=\"language-text\">&lt;script&gt;</code>: 脚本的获取和执行是同步的。此过程中页面被阻塞，停止解析。</li>\n<li><code class=\"language-text\">&lt;script defer = &quot;defer&quot;&gt;</code>：脚本的获取是异步的，执行是同步的。脚本加载不阻塞页面的解析，脚本在获取完后并不立即执行，而是等到<code class=\"language-text\">DOM</code>ready 之后才开始执行。</li>\n<li><code class=\"language-text\">&lt;script async = &quot;async&quot;&gt;</code>: 脚本的获取是异步的，执行是同步的。但是和<code class=\"language-text\">&lt;script defer = &quot;defer&quot;&gt;</code>的不同点在于脚本获取后会立刻执行，这就会造成脚本的执行顺序和页面上脚本的排放顺序不一致，可能造成脚本依赖的问题。</li>\n</ul>\n<h1>参考文献：</h1>\n<blockquote>\n<p><a href=\"http://peter.sh/experiments/asynchronous-and-deferred-javascript-execution-explained/\">Asynchronous and deferred JavaScript execution explained</a></p>\n</blockquote>","frontmatter":{"title":"图解 script 的三种加载方式","date":"2015-11-11"},"fields":{"readingTime":{"minutes":0.185}}}},"pageContext":{"slug":"/loading-script/","previous":{"fields":{"slug":"/css-triangle-generator/","readingTime":{"minutes":0.09}},"frontmatter":{"title":"css 三角形生成器","prologue":"神奇的CSS。","date":"2015-11-05"},"excerpt":"简介 输入三角形的三个内角，利用 css 的 border-width 动态生成满足条件的三角形。\n具体实现见 Github 原理说明 原理说明 演示截图 DEMO 演示"},"next":{"fields":{"slug":"/base64/","readingTime":{"minutes":2.825}},"frontmatter":{"title":"Base64 的原理、实现及应用","prologue":"因崔斯汀 :)","date":"2015-11-17"},"excerpt":"简介 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2 的 6 次方等于 64，所以每 6 个比特为一个单元，对应某个可打印字符。三个字节有 24 个比特，对应于 4 个单元，即 3 个字节需要用 4 个可打印字符来表示。它可用来作为电子邮件的传输编码。在中的可打印字符包括字母、、数字，这样共有 6…"}}},"staticQueryHashes":["1006016363","3128451518"]}