{"componentChunkName":"component---src-templates-blog-post-js","path":"/use-generator-to-control-asynchronous-code/","result":{"data":{"site":{"siteMetadata":{"title":"Notes.","author":"Natumsol"}},"markdownRemark":{"id":"ed305a34-a467-5992-98c6-e32ba5bc1e55","excerpt":"前言 当初， 引入异步（Asynchonrous）主要是为了解决浏览器端造成的 UI 假死现象，但是主流的编程语言和 Web…","html":"<h1>前言</h1>\n<p>当初，<code class=\"language-text\">JavaScript</code> 引入异步（Asynchonrous）主要是为了解决浏览器端<code class=\"language-text\">同步 IO</code>造成的 UI 假死现象，但是主流的编程语言和 Web 服务器都采取<code class=\"language-text\">同步 IO</code>的模式，原因无非是：</p>\n<ol>\n<li>采用<code class=\"language-text\">同步 IO</code>编写的代码符合人和直觉，代码容易编写和维护。</li>\n<li>对于<code class=\"language-text\">同步 IO</code>造成的线程阻塞可以通过创建多线程（进程）的方式，通过增加服务器数量进行横向扩展来解决。</li>\n</ol>\n<p>但是，在很多情况下，这种方式并不能很好地解决问题。比如对于静态资源服务器（CDN 服务器）来说，每时每刻要处理大量的文件请求，如果对于每个请求都新开一个线程（进程），可想而知，性能开销是很大的，而且有种杀鸡用牛刀的感觉。所以<code class=\"language-text\">Nginx</code>采用了和<code class=\"language-text\">JavaScript</code>相同的策略来解决这个问题——单线程、非阻塞、异步 IO。这样，当一个 IO 操作开始的时候，<code class=\"language-text\">Nginx</code> 不会等待操作完成就会去处理下一个请求，等到某个 IO 操作完成后，<code class=\"language-text\">Nginx</code> 再回过头去处理（回调）这次 IO 的后续工作。</p>\n<p>然后 2009 年<code class=\"language-text\">NodeJS</code>的发布，又极大的推进了<code class=\"language-text\">异步 IO</code>在服务端的应用，据闻，<code class=\"language-text\">NodeJS</code>在处理阿里巴巴“双十一”的海量请求高并发中发挥了很大的作用。</p>\n<p>所以，<code class=\"language-text\">异步 IO</code>真是个好东西，但是，编写异步代码却有一个无法回避的问题——回调函数嵌套太多、过多的回调层级造成阅读和维护上的困难——俗称“回调地狱（callback hell）”。</p>\n<p> <img src=\"/images/blog/20161121/1.png\" alt=\"屏幕快照 2016-11-21 下午 2.37.50\"></p>\n<p> 为了解决这个难题，出现了各种各样的解决方案。最先出来的方案是利用任务队列控制异步流程，著名的代表有 <a href=\"https://github.com/caolan/async\"><code class=\"language-text\">Async</code></a>。然后 <a href=\"https://promisesaplus.com/\"><code class=\"language-text\">Promises/A+</code></a> 规范出来了，人们根据这个规范实现了 <a href=\"https://github.com/kriskowal/q\"><code class=\"language-text\">Q</code></a>。那时候<code class=\"language-text\">Async</code>和<code class=\"language-text\">Q</code>各占边壁江山，两边都有不少忠实的拥趸， 虽然它们解决问题的思路不同，但是都很好的解决了地狱回调的问题。随着<code class=\"language-text\">ES6(ECMA Script 6)</code>将<code class=\"language-text\">Promise</code>标准纳入旗下，<code class=\"language-text\">Promise</code>成了真正意义上解决地狱回调的最佳解决方案（在支持<code class=\"language-text\">ES6</code>的环境中，开箱即用，不用引入第三方库）。</p>\n<p>但是，虽然<code class=\"language-text\">Async</code> 和 <code class=\"language-text\">Promise</code>之流都在代码层面避免了地狱回调，但是代码组织结构上并没有完全摆脱异步的影子，和纯同步的写法相比，还是有很大的不同，写起来还是略麻烦。幸好，<code class=\"language-text\">ES6</code>引入了<code class=\"language-text\">Generator</code>的概念，利用<code class=\"language-text\">Generator</code>就可以很好的解决这个问题了。</p>\n<p><img src=\"/images/blog/20161121/2.png\"></p>\n<p>可以看到，经过 Generator 重写后，代码形式上和我们熟悉的同步代码没什么二样了。😁</p>\n<p>下面我们就来介绍这种神奇的黑魔法！</p>\n<!-- more -->\n<h1>Generator 简介</h1>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function\"><code class=\"language-text\">Generator</code></a> 是<code class=\"language-text\">ES6</code>新引进的关键字，它用来定义一个<code class=\"language-text\">Generator</code>，用法和定义一个普通的函数（function）几乎一样，只是在<code class=\"language-text\">function</code>关键字和函数名之前加入了星号 <code class=\"language-text\">*</code>。<code class=\"language-text\">Generator</code>最大的特点就是定义的函数可以被暂停执行，很类似我们打断点调试代码：点<code class=\"language-text\">Run</code>按钮代码就自动执行当前语句直到遇到下一个断点并暂停，不同的是<code class=\"language-text\">Generator</code>的这种暂停态和执行态是由代码来定义和控制的。</p>\n<p>在<code class=\"language-text\">Generator</code>里，<code class=\"language-text\">yield</code>关键字用来定义代码暂停的地方，类似于给代码打断点（但不是真的打断点，不要和<code class=\"language-text\">debugger</code>关键字混淆），而<code class=\"language-text\">generator.next(value)</code>则用来控制代码的运行并处理输入输出。下面用代码来说明：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n*@description 获取自然数\n*/</span>\n<span class=\"token keyword\">function</span> <span class=\"token operator\">*</span><span class=\"token function\">getNaturalNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> seed <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> seed <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">getNaturalNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 实例化一个 Generator</span>\n\n<span class=\"token comment\">/* 启动 Generator */</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//{value: 0, done: false}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//{value: 1, done: false}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//{value: 2, done: false}</span></code></pre></div>\n<p>这是一个利用<code class=\"language-text\">Generator</code>实现的自然数生成器。通过实例化一个<code class=\"language-text\">Generator</code>，然后每次通过<code class=\"language-text\">gen.next()</code>取得一个自然数，此过程可以无限进行下去。不过值得注意的是，通过<code class=\"language-text\">gen.next()</code>取得的输出是一个对象，包含<code class=\"language-text\">value</code>和<code class=\"language-text\">done</code>两个属性，其中<code class=\"language-text\">value</code>是真正返回的值，而<code class=\"language-text\">done</code>则用来标识<code class=\"language-text\">Generator</code>是否已经执行完毕。因为自然数生成器是一个无限循环，所以不存在<code class=\"language-text\">done: true</code>的情况。</p>\n<p>这个例子比较简单，下面来个稍微复杂点的例子（涉及到输入和输出）。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @description 处理输入和输出\n */</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token operator\">*</span> <span class=\"token function\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        array<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">yield</span> array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        i <span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"西\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { value: [], done: false }</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"部\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { value: [ '部' ], done: false }</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"世\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { value: [ '部', '世' ], done: false }</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"界\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { value: [ '部', '世', '界' ], done: false }</span></code></pre></div>\n<p>有人可能会对执行结果有疑问，不清楚外部的数据是如何传到<code class=\"language-text\">Generator</code>内部的，可能会猜想是通过<code class=\"language-text\">gen.next(&quot;西&quot;)</code>这句话传进去的，但是问题又来了，为什么<code class=\"language-text\">&#39;部&#39;, &#39;世&#39;, &#39;界&#39;</code> 都传进去了，<code class=\"language-text\">&#39;西&#39;</code>去哪了？别急，且听我慢慢道来。</p>\n<p>首先我们要明白<code class=\"language-text\">yield</code>其实由两个动作组成，<strong>输入</strong> + <strong>输出</strong>（输入在输出前面），每次执行<code class=\"language-text\">next</code>，代码会暂停在<code class=\"language-text\">yield</code> <strong>输出</strong>执行后，其它的语句不再执行（<strong>很重要</strong>）。其次对于上面的例子来说，两次<code class=\"language-text\">next()</code>才真正执行完一次 while 循环。比如上面的例子里，为什么第一次输出的是<code class=\"language-text\">[]</code>, 而不是<code class=\"language-text\">[&#39;西&#39;]</code>呢？那是因为第一次执行<code class=\"language-text\">gen.next(&quot;西&quot;)</code>的时候，首先会将<code class=\"language-text\">&#39;西&#39;</code>传进去，但是并没有接受的对象，虽然<code class=\"language-text\">西</code>确实是被传进来了，但是最后被丢弃了；然后代码执行完<code class=\"language-text\">yield array</code>输出之后就暂停。然后第二次执行<code class=\"language-text\">gen.next(&quot;部&quot;)</code>的时候，会先执行输入操作，执行<code class=\"language-text\">array.push(&#39;部&#39;)</code>, 然后进行第二次循环，执行输出操作。</p>\n<p>现在总结一下：</p>\n<ol>\n<li>每个<code class=\"language-text\">yield</code>将代码分割成两个部分，需要执行两次<code class=\"language-text\">next</code>才能执行完。</li>\n<li><code class=\"language-text\">yield</code>其实由两个动作组成，<strong>输入</strong> + <strong>输出</strong>（输入在输出前面），每次执行<code class=\"language-text\">next</code>，代码会暂停在<code class=\"language-text\">yield</code> <strong>输出</strong>执行后，其它的语句不再执行（<strong>很重要</strong>）。</li>\n</ol>\n<h1>如何利用 Generator 进行异步流程控制？</h1>\n<p>利用<code class=\"language-text\">Generaotr</code>可以暂停代码执行的特性，我们通过将异步操作用<code class=\"language-text\">yield</code>关键字进行修饰，每当执行异步操作的时候，代码便在此暂停执行了。异步操作结束后，通过在回调函数里利用<code class=\"language-text\">next(data)</code>来控制<code class=\"language-text\">Generator</code>的执行流程，并顺便将异步操作的结果<code class=\"language-text\">data</code>回传给<code class=\"language-text\">Generator</code>，执行下一步。到此，整个异步流程得到了完美的控制，我们可以看一个小例子</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/Yoghurts/xnqofbep/4/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<p>可以看到，Generator 确实可以帮助我们来控制异步流程，但是上面的代比较很 raw，存在以下两个问题：</p>\n<ul>\n<li>不能自动运行，需要手动启动。</li>\n<li>不能流程控制的代码需要自己写在异步回调函数里，且没有通用性。</li>\n</ul>\n<p>所以我们需要构造一个运行器，自动处理上面提到的两个问题。</p>\n<p>TJ 大神的 <a href=\"https://github.com/tj/co\">co</a> 就是用来解决这个问题的。</p>\n<p>下面我来详细说一下解决此问题的两种方法：利用<code class=\"language-text\">Thunk</code>和<code class=\"language-text\">Promise</code></p>\n<h2>利用 Thunk 来构造 generator 自动运行器</h2>\n<p>这里引入了一个新的概念——thunk（ 读音 [θʌŋk] ），为了帮助理解，下面单独来介绍一下 thunk。</p>\n<h3>Thunk</h3>\n<p>维基百科上的介绍如下：</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Computer_programming\">computer programming</a>, a <strong>thunk</strong> is a <a href=\"https://en.wikipedia.org/wiki/Subroutine\">subroutine</a> that is created, often automatically, to assist a call to another subroutine. Thunks are primarily used to represent an additional calculation that a subroutine needs to execute, or to call a routine that does not support the usual calling mechanism. They have a variety of other applications to <a href=\"https://en.wikipedia.org/wiki/Code_generation_(compiler)\">compiler code generation</a> and in <a href=\"https://en.wikipedia.org/wiki/Modular_programming\">modular programming</a>.</p>\n</blockquote>\n<p>可以简单理解为，thunk 就是为了满足函数（子程序）调用的<strong>特殊需要</strong>，对原函数（子程序）进行了特殊的改造，主要用在编译器的代码生成（传名调用）和模块化编程中。</p>\n<p>在<code class=\"language-text\">JavaScript</code>中的<code class=\"language-text\">thunk</code>化指的是将多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数，比如<code class=\"language-text\">NodeJs</code>的<code class=\"language-text\">fs.readFile</code>函数，<code class=\"language-text\">tnunk</code>化为：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">readFile</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">filename</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// 包装为高阶函数</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cb</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>为了接下来的方便，我们在这里先构造一个<code class=\"language-text\">thunkify</code>函数，专门对函数进行<code class=\"language-text\">thunk</code>化：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">thunkify</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fn</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> pass<span class=\"token punctuation\">;</span> \n    args<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pass<span class=\"token punctuation\">)</span> <span class=\"token function\">pass</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 植入回调函数，里面包含控制逻辑</span>\n    <span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      pass <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 外部可注入的控制逻辑</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>运行器</h3>\n<p>现在开始构造我们的运行器。思路也很简单，运行器接受一个<code class=\"language-text\">Generator</code>函数，实例化一个<code class=\"language-text\">Generator</code>对象，然后启动任务，通过<code class=\"language-text\">next()</code>取得返回值，这个返回值其实是一个函数，提供了一个入口可以让我们可以方便的注入控住逻辑，包括：控制<code class=\"language-text\">Generator</code>向下执行、将异步执行的结果返回给<code class=\"language-text\">Generator</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">generator</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">generator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> ret <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将数据传回 Generator</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    ret<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 启动任务</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>测试</h3>\n<p>下面我们来测试一下代码是否按照我们的预期运行。</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/Yoghurts/727audwe/embedded/js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<p>可以看到，完全符合我们的预期！</p>\n<h3>缺陷</h3>\n<p>虽然以上 Thunk 函数能完美实现我们对异步流程的控制，但是对于同步任务却不能正确的做出反应，比如我写一个同步版的<code class=\"language-text\">readFileSync</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">_readFileSync</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">filename<span class=\"token punctuation\">,</span> cb</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">cb</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> file<span class=\"token punctuation\">[</span>filename<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然后将<code class=\"language-text\">var readFile = thunkify(_readFile); // 将_readFile thunk 化</code>改为<code class=\"language-text\">var readFile = thunkify(_readFileSync)</code>其余均保持不变，运行代码会发现执行不成功。什么原因造成的呢？其实只要仔细分析就会发现，主要问题主要出现在<code class=\"language-text\">thunkify</code>函数上面，在<strong>流程控制函数</strong>注入之前，任务函数就已经执行了，如果这个任务是异步的，那没问题，因为异步任务回调函数只会等主线程空闲了才会执行，所以异步任务能确保控制函数能够被成功注入。但是如果这个任务是同步的，那就不一样了。传给同步任务的回调函数会被立刻执行，之后给它注入控制逻辑已经没用了，因为同步任务早已执行完。</p>\n<h3>改进</h3>\n<p>为了改进<code class=\"language-text\">thunkify</code>函数，让它能适应同步的情况，可以考虑将<strong>任务函数</strong>的执行延后到控制逻辑注入后执行，这样就能确保无论任务函数异步也好，同步也罢，都能注入控制逻辑。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n* 重写 thunkify 函数，使其能兼容同步任务\n*/</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">thunkify</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> ctx <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">done</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> called<span class=\"token punctuation\">;</span>\n      args<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>called<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n        called <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">done</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">fn</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将任务函数置后运行</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">done</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>改进后的：</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/Yoghurts/65s0dpu2/embedded/js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<h2>利用 Promise 来构造 generator 自动运行器</h2>\n<p>有了上面的基础，基于 Promise 就会容易理解多了。</p>\n<h3>toPromise</h3>\n<p>首先，我们应该将异步任务改造成 Promsie 的形式，为了兼容同步任务，我们先对任务进行 thunkify 统一化，然后再转化为 Promise。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">toPromise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> thunkify_fn <span class=\"token operator\">=</span> <span class=\"token function\">thunkify</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 先 thunkify 化</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 返回 Promise</span>\n            <span class=\"token function\">thunkify_fn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>  <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>运行器</h3>\n<p>因为 Promise 是标准化的，所以构造 Promise 的运行器比较简单，我就直接 show code 了：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">generator</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">generator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> ret <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"done\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   \t<span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n    \t<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span> <span class=\"token operator\">=></span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    \t<span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ex</span> <span class=\"token operator\">=></span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">throw</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>测试</h3>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/Yoghurts/szkpdxf0/embedded/js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<p>经测试，完全符合要求。</p>\n<h1>小结</h1>\n<p>异步流程的控制一直是<code class=\"language-text\">JavaScript</code>比较令人头疼的一点，<code class=\"language-text\">Generator</code>的出现无疑是一件囍事，相信随着 ES6 的普及以及 ES7 的推进（ES 7 的<code class=\"language-text\">async</code>，<code class=\"language-text\">await</code>)，异步代码那反直觉的编写方式将一去不复返，编写和维护异步代码将会越来越容易，JavaScript 也将会越来越成熟，受到越来越多人的喜爱。</p>\n<h1>参考文献</h1>\n<ul>\n<li><a href=\"http://www.infoq.com/cn/articles/generator-and-asynchronous-programming#\">Generator 与异步编程</a></li>\n<li><a href=\"https://www.promisejs.org/generators/\">Generators by Forbes Lindesay</a></li>\n<li><a href=\"http://huli.logdown.com/posts/292331-javascript-es6-generator-foundation\">ES6 Generator 基礎</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/async\">ECMAScript 6 入门</a></li>\n</ul>","frontmatter":{"title":"利用 Generator 实现 JavaScript 异步流程控制","date":"2016-11-21"},"fields":{"readingTime":{"minutes":3.085}}}},"pageContext":{"slug":"/use-generator-to-control-asynchronous-code/","previous":{"fields":{"slug":"/lazyman/","readingTime":{"minutes":1.095}},"frontmatter":{"title":"如何实现一个 LazyMan?","prologue":"因崔斯汀 :)","date":"2016-09-09"},"excerpt":"…"},"next":{"fields":{"slug":"/the-moon-and-sixpence/","readingTime":{"minutes":0.145}},"frontmatter":{"title":"月亮与六便士","prologue":"We are all in the gutter，but some of us are looking at the stars.","date":"2017-02-28"},"excerpt":"We are all in the gutter，but some of us are looking at the stars.\n我们都身处阴沟之中，但仍有人在仰望星空。\n——Oscar Wilde…"}}},"staticQueryHashes":["1006016363","3128451518"]}